# スクリプト一式（最終版）

## ファイル構成

```
cw-alarm-threshold-tester/
├─ app.py         ← ハンドラ
└─ requirements.txt（空で可）
```

* ZIP名: `cw-alarm-threshold-tester.zip`
* ランタイム: Python 3.12
* ハンドラ: `app.handler`

---

## 環境変数

* `PARAM_NAME` = 〈パラメータストア名〉（例 `/cw-alarm-backup/prod`）
* `FORCE_ONE_DATAPOINT` = `true` or `false`（既定 `false`）
* `AWS_REGION` はLambdaリージョンを使用（明示不要）

---

## IAM（最小）

### 信頼ポリシー（ロールのAssumeRole）

```json
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": {"Service":"lambda.amazonaws.com"},
    "Action": "sts:AssumeRole"
  }]
}
```

### アタッチする権限ポリシー

```json
{
  "Version":"2012-10-17",
  "Statement":[
    {
      "Sid":"CW",
      "Effect":"Allow",
      "Action":[
        "cloudwatch:DescribeAlarms",
        "cloudwatch:PutMetricAlarm"
      ],
      "Resource":"*"
    },
    {
      "Sid":"SSMParamRW",
      "Effect":"Allow",
      "Action":[
        "ssm:GetParameter",
        "ssm:PutParameter"
      ],
      "Resource":"*"
    },
    {
      "Sid":"Logs",
      "Effect":"Allow",
      "Action":[
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource":"*"
    }
  ]
}
```

---

## デプロイ手順（CLI）

```bash
# 1) パッケージ化
cd cw-alarm-threshold-tester
zip -r ../cw-alarm-threshold-tester.zip app.py requirements.txt
cd ..

# 2) ロール作成
aws iam create-role --role-name cw-alarm-threshold-tester-role \
  --assume-role-policy-document file://trust.json

aws iam put-role-policy --role-name cw-alarm-threshold-tester-role \
  --policy-name cw-alarm-threshold-tester-inline \
  --policy-document file://policy.json

# 3) 関数作成
aws lambda create-function \
  --function-name cw-alarm-threshold-tester \
  --runtime python3.12 \
  --role arn:aws:iam::<ACCOUNT_ID>:role/cw-alarm-threshold-tester-role \
  --handler app.handler \
  --timeout 900 --memory-size 512 \
  --environment "Variables={PARAM_NAME=/cw-alarm-backup/prod,FORCE_ONE_DATAPOINT=false}" \
  --zip-file fileb://cw-alarm-threshold-tester.zip
```

---

## 実行方法

* 更新（しきい値を“異常側”に寄せる）:

```bash
aws lambda invoke \
  --function-name cw-alarm-threshold-tester \
  --payload '{"action":"update"}' \
  out.json && cat out.json
```

* ロールバック（元に戻す）:

```bash
aws lambda invoke \
  --function-name cw-alarm-threshold-tester \
  --payload '{"action":"rollback"}' \
  out.json && cat out.json
```

> 1リージョン単位。ap-northeast-1 で関数を作る。

---

## しきい値の変更ルール（再掲・根拠付き）

| 監視                           | 現行例                | 一時値                    | 根拠                |
| ---------------------------- | ------------------ | ---------------------- | ----------------- |
| LogicalDisk `% Free Space`   | `<= 10`            | `<= 99.5`              | 99.5%未満はほぼ常時 → 違反 |
| Memory `Available Bytes`     | `<= 1,717,986,918` | `<= 1,000,000,000,000` | 1TBは通常値より十分大 → 違反 |
| Processor `% Processor Time` | `> 90`             | `> 1`                  | CPU>1%は頻発 → 違反    |
| `StatusCheckFailed_Instance` | `>= 1`             | `>= 0`                 | 0でも条件成立 → 違反      |
| `StatusCheckFailed_System`   | `>= 1`             | `>= 0`                 | 同上                |
| `Windows_service_status`     | `< 1`              | `< 2`                  | 稼働=1でも 1<2 → 違反   |

* 評価設定は**既定を維持**。`FORCE_ONE_DATAPOINT=true` のときのみ `EvaluationPeriods=1 / DatapointsToAlarm=1` を上書き。

---

## app.py（ハンドラ本体）

```python
import os, json, urllib.parse, time
import boto3

REGION = os.environ.get("AWS_REGION", "ap-northeast-1")
PARAM_NAME = os.environ.get("PARAM_NAME")  # 〈パラメータストア名〉
FORCE_ONE = os.environ.get("FORCE_ONE_DATAPOINT", "false").lower() == "true"

cw  = boto3.client("cloudwatch", region_name=REGION)
ssm = boto3.client("ssm",        region_name=REGION)

# ---- しきい値変換ロジック ----
def decide_new_threshold(a):
    # 単一メトリクス以外は対象外（Metrics フィールドを持つ＝メトリックマスは除外）
    if "MetricName" not in a or a.get("Metrics"):
        return None

    m = (a["MetricName"] or "").lower()
    comp = a["ComparisonOperator"]
    thr  = a["Threshold"]

    # 1 LogicalDisk % Free Space <=10 → <=99.5
    if "logicaldisk" in m and "% free space" in m and comp.endswith("LessThanOrEqualToThreshold") and float(thr) == 10.0:
        return {"ComparisonOperator": comp, "Threshold": 99.5}

    # 2 Memory Available Bytes <= 1717986918 → <= 1e12
    if "memory" in m and "available" in m and "bytes" in m and comp.endswith("LessThanOrEqualToThreshold") and int(thr) == 1717986918:
        return {"ComparisonOperator": comp, "Threshold": 1_000_000_000_000}

    # 3 Processor % Processor Time > 90 → > 1
    if "processor" in m and "% processor time" in m and comp.endswith("GreaterThanThreshold") and float(thr) == 90.0:
        return {"ComparisonOperator": comp, "Threshold": 1.0}

    # 4/5 StatusCheckFailed_* >= 1 → >= 0
    if a["MetricName"] in ("StatusCheckFailed", "StatusCheckFailed_Instance", "StatusCheckFailed_System") \
       and comp.endswith("GreaterThanOrEqualToThreshold") and float(thr) == 1.0:
        return {"ComparisonOperator": comp, "Threshold": 0.0}

    # 6 Windows_service_status < 1 → < 2
    if "windows" in m and "service" in m and "status" in m and comp.endswith("LessThanThreshold") and float(thr) == 1.0:
        return {"ComparisonOperator": comp, "Threshold": 2.0}

    return None

# ---- Parameter Store にアラーム単位で保存（サイズ対策のため分割） ----
def param_key_for_alarm(alarm_name):
    # 〈パラメータストア名〉/encodedAlarmName
    encoded = urllib.parse.quote(alarm_name, safe='')
    return f"{PARAM_NAME}/{encoded}"

def save_snapshot(alarm_name, payload):
    ssm.put_parameter(
        Name=param_key_for_alarm(alarm_name),
        Type="String",
        Overwrite=True,
        Value=json.dumps(payload, ensure_ascii=False)
    )

def load_snapshot(alarm_name):
    try:
        r = ssm.get_parameter(Name=param_key_for_alarm(alarm_name))
        return json.loads(r["Parameter"]["Value"])
    except ssm.exceptions.ParameterNotFound:
        return None

# ---- put_metric_alarm 用の引数を現在定義から構築 ----
def build_put_args_from(a):
    args = {
        "AlarmName": a["AlarmName"],
        "ComparisonOperator": a["ComparisonOperator"],
        "Threshold": a["Threshold"],
        "EvaluationPeriods": a.get("EvaluationPeriods"),
        "DatapointsToAlarm": a.get("DatapointsToAlarm"),
        "ActionsEnabled": a.get("ActionsEnabled", True),
        "AlarmActions": a.get("AlarmActions", []),
        "OKActions": a.get("OKActions", []),
        "InsufficientDataActions": a.get("InsufficientDataActions", []),
        "MetricName": a["MetricName"],
        "Namespace": a["Namespace"],
        "Statistic": a.get("Statistic"),
        "ExtendedStatistic": a.get("ExtendedStatistic"),
        "Period": a["Period"],
        "Unit": a.get("Unit"),
        "Dimensions": a.get("Dimensions", []),
        "TreatMissingData": a.get("TreatMissingData", "missing"),
        "Tags": a.get("Tags", [])
    }
    # None を除去（boto要件）
    return {k:v for k,v in args.items() if v is not None}

def update_one(a):
    rule = decide_new_threshold(a)
    if not rule:
        return None

    before = build_put_args_from(a)
    after  = dict(before)
    after["ComparisonOperator"] = rule["ComparisonOperator"]
    after["Threshold"] = rule["Threshold"]

    if FORCE_ONE:
        after["EvaluationPeriods"] = 1
        after["DatapointsToAlarm"] = 1

    # put
    cw.put_metric_alarm(**after)

    # 保存形式: before/after/rollback を保持（rollback=beforeと同）
    save_snapshot(a["AlarmName"], {
        "before": before,
        "after": after,
        "rollback": before
    })
    return {"name": a["AlarmName"], "change": {"from": before["Threshold"], "to": after["Threshold"]}}

def rollback_one(name):
    snap = load_snapshot(name)
    if not snap:
        return {"name": name, "status": "skip(no-snapshot)"}
    rb = snap["rollback"]
    cw.put_metric_alarm(**rb)
    return {"name": name, "status": "reverted"}

def describe_all_metric_alarms():
    paginator = cw.get_paginator("describe_alarms")
    for page in paginator.paginate():
        for a in page.get("MetricAlarms", []):
            # 複合アラーム除外
            if a.get("Metrics"): 
                continue
            yield a

def handler(event, context):
    action = (event or {}).get("action", "update")
    updated = []
    reverted = []

    if action == "update":
        for a in describe_all_metric_alarms():
            r = update_one(a)
            if r:
                updated.append(r)
            time.sleep(0.1)  # 軽いスロットリング対策
        return {"result": "updated", "count": len(updated), "items": updated}

    elif action == "rollback":
        # 直近スナップショット対象はパラメータ一覧が必要だが、キー列挙APIなしのため
        # 実在アラーム名に対し存在するスナップショットのみ復元
        names = [a["AlarmName"] for a in describe_all_metric_alarms()]
        for n in names:
            r = rollback_one(n)
            if r:
                reverted.append(r)
            time.sleep(0.05)
        return {"result": "rolled_back", "count": len(reverted), "items": reverted}

    else:
        return {"error": "unknown action"}
```

---

## ポイント

* **全ディメンション含む** before/after/rollback を**アラーム単位**で Parameter Store に保存
  → `〈パラメータストア名〉/<URLエンコード済みAlarmName>`
  → サイズ上限対策・差分比較が容易
* **抽出条件**は「あなたが渡した現行しきい値」に**厳密一致**したものだけ更新
* **評価設定は維持**。`FORCE_ONE_DATAPOINT=true` のときのみ 1/1 に上書き
* 複合/メトリックマスは**除外**
* ロールバックは「現存アラーム名」×「スナップショット存在時のみ」復元

これで実行→検証→ロールバックまで一連で回せる。
