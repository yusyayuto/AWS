import os, json, time
import boto3
from botocore.exceptions import ClientError

cw  = boto3.client("cloudwatch")
ssm = boto3.client("ssm")
ddb = boto3.client("dynamodb")

DOC  = os.environ.get("AUTOMATION_DOC")
P_IID = os.environ.get("PARAM_KEY_INSTANCE_ID", "InstanceId")
P_ALM = os.environ.get("PARAM_KEY_COMPOSITE",  "CompositeAlarmName")
DDB_TABLE = os.environ["IDEMPOTENCY_TABLE"]

def _idempotent_or_skip(event_id: str, ttl_sec: int = 600) -> bool:
    ttl = int(time.time()) + ttl_sec
    try:
        ddb.put_item(
            TableName=DDB_TABLE,
            Item={"key": {"S": f"ev#{event_id}"}, "ttl": {"N": str(ttl)}},
            ConditionExpression="attribute_not_exists(#k)",
            ExpressionAttributeNames={"#k":"key"}
        )
        return True
    except ClientError as e:
        if e.response["Error"]["Code"] == "ConditionalCheckFailedException":
            return False
        raise

def lambda_handler(event, _):
    # 1) 冪等化（同じ event.id は一度だけ）
    ev_id = event.get("id")
    if ev_id and not _idempotent_or_skip(ev_id):
        print(f"Duplicate event: {ev_id}")
        return {"status":"duplicate", "eventId": ev_id}

    # 2) 情報取り出し
    comp  = event["detail"]["alarmName"]
    rjson = json.loads(event["detail"]["state"]["reasonData"])
    child_arn = rjson["triggeringAlarms"][0]["arn"]  # 先頭だけ採用（割り切り）
    child = child_arn.split(":alarm:", 1)[1]

    # 3) 子アラーム定義から InstanceId を取得
    dr = cw.describe_alarms(AlarmNames=[child])
    dims = dr["MetricAlarms"][0].get("Dimensions", [])
    iid  = next((d["Value"] for d in dims if d.get("Name")=="InstanceId"), None)
    if not iid:
        raise RuntimeError(f"No InstanceId in alarm: {child}")

    # 4) SSM Automation を起動（ClientToken に event.id を使って二重防止）
    ssm.start_automation_execution(
        DocumentName=DOC,
        Parameters={P_IID: [iid], P_ALM: [comp]},
        ClientToken=ev_id or f"{comp}-{int(time.time())}"
    )

    return {"status":"started", "instanceId": iid, "composite": comp, "child": child}